# UM6P Data Management Lab 7 - Parts 3 & 4

## Part 3: Identifying Types of Schedules

**Context:**
* Transaction 1 ($T_1$): R(A), W(A)
* Transaction 2 ($T_2$): R(B), W(B)
* Schedule $S_1$: $R_1(A), R_2(B), W_1(A), W_2(B)$
* Schedule $S_2$: $R_1(A), W_1(A), R_2(B), W_2(B)$

### 1. Are the schedules $S_1$ and $S_2$ equivalent? Justify your answer.

**Answer:** Yes.

**Justification:**
Two schedules are **conflict equivalent** if they have the same operations and the order of all *conflicting* operations is the same.
* $T_1$ reads and writes item **A**.
* $T_2$ reads and writes item **B**.
* Because A and B are different data items, there are **no conflicting operations** between $T_1$ and $T_2$.
* When there are no conflicts, the operations can be swapped freely without changing the result. Therefore, the interleaved schedule $S_1$ is equivalent to the serial schedule $S_2$.

### 2. Is $S_1$ serializable? If yes, give an equivalent serial schedule.

**Answer:** Yes.

**Equivalent Serial Schedule:**
Since there are no conflicts, $S_1$ is equivalent to any serial order of the transactions.
* **Option A:** $T_1 \to T_2$ ($R_1(A), W_1(A), R_2(B), W_2(B)$)
* **Option B:** $T_2 \to T_1$ ($R_2(B), W_2(B), R_1(A), W_1(A)$)

---

## Part 4: Conflict Serializability

**Context:**
* $T_1$: R(A), W(A)
* $T_2$: W(A), R(B)
* $T_3$: R(A), W(B)
* Schedule $S_3$: $R_1(A), W_2(A), R_3(A), W_1(A), W_3(B), R_2(B)$

### 1. Construct the precedence (dependency) graph for $S_3$

To verify conflict serializability, we look for conflicting operations (Read-Write, Write-Read, Write-Write) on the same data item where the operation in one transaction precedes the other.

**Conflicts identified in Schedule $S_3$:**

1.  **Conflict on A ($R_1$ vs $W_2$):**
    * $R_1(A)$ occurs before $W_2(A)$.
    * **Edge:** $T_1 \to T_2$
2.  **Conflict on A ($W_2$ vs $R_3$):**
    * $W_2(A)$ occurs before $R_3(A)$.
    * **Edge:** $T_2 \to T_3$
3.  **Conflict on A ($W_2$ vs $W_1$):**
    * $W_2(A)$ occurs before $W_1(A)$.
    * **Edge:** $T_2 \to T_1$
4.  **Conflict on A ($R_3$ vs $W_1$):**
    * $R_3(A)$ occurs before $W_1(A)$.
    * **Edge:** $T_3 \to T_1$
5.  **Conflict on B ($W_3$ vs $R_2$):**
    * $W_3(B)$ occurs before $R_2(B)$.
    * **Edge:** $T_3 \to T_2$

**Resulting Precedence Graph (Text Representation):**
* Node $T_1$ has incoming edges from $T_2$ and $T_3$.
* Node $T_2$ has incoming edges from $T_1$ and $T_3$.
* Node $T_3$ has incoming edges from $T_2$.

**Visual Logic:**
* $T_1 \leftrightarrow T_2$ (Double arrow / Cycle)
* $T_2 \leftrightarrow T_3$ (Double arrow / Cycle)

### 2. Is $S_3$ conflict serializable? Justify your answer using the graph.

**Answer:** No.

**Justification:**
A schedule is conflict serializable **if and only if its precedence graph is acyclic** (contains no cycles). The graph for $S_3$ contains multiple cycles, which proves it is not serializable.

**Cycles present in the graph:**
1.  **Cycle 1 ($T_2$ and $T_3$):** We have an edge $T_2 \to T_3$ (due to conflict on A) and an edge $T_3 \to T_2$ (due to conflict on B).
2.  **Cycle 2 ($T_1$ and $T_2$):** We have an edge $T_1 \to T_2$ (due to $R_1$ before $W_2$) and an edge $T_2 \to T_1$ (due to $W_2$ before $W_1$).

Because these cycles exist, there is no valid serial order that respects all dependencies.


---

## Part 5: 2PL:

This section analyzes the following schedules to determine if they can be generated by a database system enforcing strict 2PL protocol.

### 1-Schedule 1:

**Is it compatible with strict 2PL:** No.

**Justification:** $T_1$ executes $W_1(A)$ and must acquire an Exclusive lock ($X(A)$). Under Strict 2PL, this $X(A)$ lock must be held until $T_1$ commits. However, the schedule shows $T_2$ attempting $R_2(A)$ immediately after $W_1(B)$, while $T_1$ is still uncommitted. Since $X(A)$ is incompatible with $T_2$'s required Shared lock ($S(A)$), $T_2$'s operation must be blockedd. The schedule is illegal because it shows $R_2(A)$ executing before $T_1$ releases its write lock on $A$.

### 2-Schedule 2:

**Is it compatible with strict 2PL:** No.

**Justification:** $T_2$ executes $W_2(B)$ and must acquire an Exclusive lock ($X(B)$). Under Strict 2PL, $X(B)$ must be held until $T_2$ commits. However, the schedule shows $T_1$ attempting $R_1(B)$ immediately after $W_2(B)$, while $T_2$ is still uncommitted. Since $X(B)$ is incompatible with $T_1$'s required Shared lock ($S(B)$), $T_1$'s operation must be blocked. The schedule is illegal because it shows $R_1(B)$ executing before $T_2$ releases its write lock on $B$.

### 3-Schedule 3:

**Is it compatible with strict 2PL:** Yes!

**Justification:** The two transactions operate on disjoint sets of data items ($T_1$ uses A, B; $T_2$ uses C). Therefore, there are no lock conflicts. Both transactions acquire their necessary locks ($X(A)$, $X(B)$, $X(C)$) in their growing phases and hold them throughout their execution until commit, satisfying both the 2PL and the strictness requirements.

### 4-Schedule 4:

**Is it compatible with strict 2PL:** No. 

**Justification:** $T_1$ executes $W_1(A)$ and must acquire an Exclusive lock ($X(A)$). Under Strict 2PL, this $X(A)$ lock must be held until $T_1$ commits. However, the schedule shows $T_2$ attempting $R_2(A)$ immediately after $W_1(A)$, while $T_1$ is still uncommitted. Since $X(A)$ is incompatible with $T_2$'s required Shared lock ($S(A)$), $T_2$'s operation must be blocked. The schedule is illegal because it shows $R_2(A)$ executing before $T_1$ releases its write lock on $A$.



